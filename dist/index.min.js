"use strict";export var physics;(function(l){let g;(function(t){t[t.CIRCLE=0]="CIRCLE",t[t.RECTANGLE=1]="RECTANGLE"})(g=l.ShapeType||(l.ShapeType={}));function oe(t){t.dynamicBodies.sort((e,i)=>e.id-i.id),t.staticBodies.sort((e,i)=>e.id-i.id),t.disabledBodies.sort((e,i)=>e.id-i.id),t.joints.sort((e,i)=>e.id-i.id),t.dynamicBodies.forEach(e=>e.shapes.sort((i,n)=>i.id-n.id)),t.staticBodies.forEach(e=>e.shapes.sort((i,n)=>i.id-n.id)),t.disabledBodies.forEach(e=>e.shapes.sort((i,n)=>i.id-n.id))}l.ensureOrder=oe;function O(t,e){return[...e??t.dynamicBodies,...t.staticBodies,...t.disabledBodies]}l.allBodies=O;function Q(t,e){return[...e??t.dynamicBodies,...t.staticBodies]}l.enabledBodies=Q;function ce(t,e,i){const n=(i??t.dynamicBodies).findIndex(f=>f.id===e.id);n!==-1&&(i??t.dynamicBodies).splice(n,1);const r=t.staticBodies.findIndex(f=>f.id===e.id);r!==-1&&t.staticBodies.splice(r,1),t.disabledBodies.includes(e)||t.disabledBodies.push(e)}l.disableBody=ce;function re(t,e,i){!e.static&&!(i??t.dynamicBodies).find(n=>n.id===e.id)&&(i??t.dynamicBodies).push(e),e.static&&!t.staticBodies.includes(e)&&t.staticBodies.push(e),t.disabledBodies.includes(e)&&t.disabledBodies.splice(t.disabledBodies.indexOf(e),1)}l.enableBody=re;function fe(t,e=!1,i){const n=e?t.staticBodies:O(t,i);if(n.length===0)return{min:m(0,0),max:m(0,0)};const r=n[0];let f=m(r.shapes[0].center.x-r.shapes[0].bounds,r.center.y-r.shapes[0].bounds),s=m(r.shapes[0].center.x+r.shapes[0].bounds,r.center.y+r.shapes[0].bounds);for(const y of n)for(const c of y.shapes)if(c.type===g.CIRCLE)f.x=Math.min(f.x,c.center.x-c.bounds),f.y=Math.min(f.y,c.center.y-c.bounds),s.x=Math.max(s.x,c.center.x+c.bounds),s.y=Math.max(s.y,c.center.y+c.bounds);else if(c.type===g.RECTANGLE)for(const a of c.vertices)f.x=Math.min(f.x,a.x),f.y=Math.min(f.y,a.y),s.x=Math.max(s.x,a.x),s.y=Math.max(s.y,a.y);return{min:f,max:s}}l.getWorldBounds=fe;function ue(t,e=1){return{staticBodies:[],dynamicBodies:[],disabledBodies:[],gravity:t??m(0,100),angularDamp:1,damp:1,nextId:1,joints:[],frameCount:0,jointRestriction:1,restTime:e,exclusions:{},paused:!1,iterationCount:9}}l.createWorld=ue;function le(t,e,i){t.exclusions[e.id]=t.exclusions[e.id]??[],t.exclusions[e.id].includes(i.id)||t.exclusions[e.id].push(i.id),t.exclusions[i.id]=t.exclusions[i.id]??[],t.exclusions[i.id].includes(e.id)||t.exclusions[i.id].push(e.id)}l.excludeCollisions=le;function de(t,e,i){t.exclusions[e.id]&&(t.exclusions[e.id]=t.exclusions[e.id].filter(n=>i.id===n)),t.exclusions[i.id]&&(t.exclusions[i.id]=t.exclusions[e.id].filter(n=>e.id===n))}l.includeCollisions=de;function pe(t,e,i,n=1,r=0,f=!1){const s={id:t.nextId++,bodyA:e.type==="BODY"?e.id:e.bodyId,bodyB:i.type==="BODY"?i.id:i.bodyId,distance:0,rigidity:n,elasticity:r,soft:f,shapeA:e.type!=="BODY"?e.id:0,shapeB:i.type!=="BODY"?i.id:0},y=O(t).find(u=>u.id===s.bodyA),c=O(t).find(u=>u.id===s.bodyB);if(!y||!c)throw"Body A is not part of world. Joints must be connected to elements in the world";const a=s.shapeA?y.shapes.find(u=>u.id===s.shapeA).center:y.center,p=s.shapeB?c.shapes.find(u=>u.id===s.shapeB).center:c.center;s.distance=E(B(a,p)),t.joints.push(s)}l.createJoint=pe;function ye(t,e,i,n,r,f,s=!1,y){const c=w(t,e,i,s);return z(t,e,n,r,f,[c],y)}l.createCircle=ye;function xe(t,e,i,n,r,f,s,y=!1,c){const a=ee(t,e,i,n,0,y);return z(t,e,r,f,s,[a],c)}l.createRectangle=xe;function U(t,e){L(t,e,!0)}l.moveBody=U;function L(t,e,i=!1){if(!(!i&&t.static)){t.center=v(t.center,e),t.static||(t.centerOfPhysics=v(t.centerOfPhysics,e));for(const n of t.shapes)if(n.center=v(n.center,e),n.type===g.RECTANGLE){for(let r=4;r--;)n.vertices[r]=v(n.vertices[r],e);ie(n)}}}function he(t,e){const i=B(e,t.center);U(t,i)}l.setCenter=he;function me(t,e){const i=e-t.angle;t.static||(t.centerOfPhysics={...t.center}),F(t,i)}l.setRotation=me;function F(t,e){if(!e)return;t.angle+=e,t.static||(t.averageAngle=t.angle);const i=t.static?t.center:t.centerOfPhysics;t.center=G(t.center,i,e);for(const n of t.shapes)if(n.center=G(n.center,i,e),n.type===g.RECTANGLE){for(let r=4;r--;)n.vertices[r]=G(n.vertices[r],i,e);Me(n),ie(n)}}l.rotateBody=F;function Be(t,e,i,n,r){const f=e.bodyA===i.id?e.shapeA:e.shapeB,s=e.bodyA===i.id?e.shapeB:e.shapeA,y=f?i.shapes.find(o=>o.id===f).center:i.center,c=s?n.shapes.find(o=>o.id===s).center:n.center;let a=B(c,y);if(E(a)-e.distance!=0){if(!i.static){const C=B(i.centerOfPhysics,y);if(E(C)>0){let h=Z(a,C);h>Math.PI&&(h=Math.PI-h),h<-Math.PI&&(h=Math.PI*2+h),i.angularVelocity+=h/r}}a=B(c,y);const o=E(a),x=o-e.distance;x!=0&&(x>0?a=d(a,1/o*x*(1-e.elasticity)*(n.static?1:.5)):a=d(a,1/o*x*e.rigidity*(n.static?1:.5)),!e.soft&&!i.static&&L(i,a),!e.soft&&!n.static&&L(n,d(a,-1)),i.static||(i.velocity=v(i.velocity,d(a,e.soft?1:r/2))),n.static||(n.velocity=v(n.velocity,d(a,-(e.soft?1:r/2)))))}}function ge(t,e,i){if(e.paused)return[];e.frameCount++,i=i??e.dynamicBodies;const n=Q(e,i),r=O(e,i);let f=[];for(const s of r)s.shapes.forEach(y=>{!s.static&&s.restingTime>e.restTime||(y.sensorColliding=!1,y.sensorCollisions=[])});for(const s of i)!s.velocity&&!s.acceleration||(s.velMag!==E(s.velocity)&&(s.restingTime=0),!S(e,s)&&(s.fixedPosition?(s.velocity.x=0,s.velocity.y=0):(s.velocity=v(s.velocity,d(s.acceleration,1/t)),L(s,d(s.velocity,1/t))),s.fixedRotation?(s.angularVelocity=0,s.angularAcceleration=0):(s.angularVelocity+=s.angularAcceleration*1/t,F(s,s.angularVelocity*1/t))));for(let s=e.iterationCount;s--;){let y=!1;for(const c of i){const a=e.joints.filter(p=>p.bodyA===c.id||p.bodyB===c.id);for(const p of a){const u=p.bodyA===c.id?p.bodyB:p.bodyA,o=r.find(x=>x.id===u);o&&(Be(e,p,c,o,t),(c.static||o.static)&&(c.static||(c.velocity.x-=c.velocity.x*(1-e.damp)/t*e.jointRestriction,c.velocity.y-=c.velocity.y*(1-e.damp)/t*e.jointRestriction,c.angularVelocity-=c.angularVelocity*(1-e.angularDamp)/t*e.jointRestriction),o.static||(o.velocity.x-=o.velocity.x*(1-e.damp)/t*e.jointRestriction,o.velocity.y-=o.velocity.y*(1-e.damp)/t*e.jointRestriction,o.angularVelocity-=o.angularVelocity*(1-e.angularDamp)/t*e.jointRestriction)))}}for(let c=i.length;c--;){const a=i[c];if(a.velocity)for(let p=n.length;p-- >c;){if(c===p)continue;const u=n[p];if(!e.exclusions[u.id]?.includes(a.id)&&!e.exclusions[a.id]?.includes(u.id)&&te(a,u)){let o=Y();if(se(e,a,u,o)){if(o.shapeA&&o.shapeA.sensor){o.shapeA.sensorColliding=!0,o.shapeB&&o.shapeA.sensorCollisions.push(o.shapeB.id);continue}if(o.shapeB&&o.shapeB.sensor){o.shapeB.sensorColliding=!0,o.shapeA&&o.shapeB.sensorCollisions.push(o.shapeA.id);continue}if(u.permeability>0){a.velocity.x*=1-u.permeability,a.velocity.y*=1-u.permeability,a.angularVelocity*=1-u.permeability;continue}a.static||(a.shapes.includes(o.shapeA)&&!o.shapeA.sensor&&(a.centerOfPhysics={...o.shapeA.center},a.inertia=o.shapeA.inertia),a.shapes.includes(o.shapeB)&&!o.shapeB.sensor&&(a.centerOfPhysics={...o.shapeB.center},a.inertia=o.shapeB.inertia)),u.static||(u.shapes.includes(o.shapeA)&&!o.shapeA.sensor&&(u.centerOfPhysics={...o.shapeA.center},u.inertia=o.shapeA.inertia),u.shapes.includes(o.shapeB)&&!o.shapeB.sensor&&(u.centerOfPhysics={...o.shapeB.center},u.inertia=o.shapeB.inertia)),R(o.normal,B(u.center,a.center))<0&&(o={depth:o.depth,normal:d(o.normal,-1),start:o.end,end:o.start,shapeA:o.shapeB,shapeB:o.shapeA}),Ve(e,a,u,o)&&(y=!0,f=f.filter(x=>x.bodyAId!==a.id&&x.bodyBId!==u.id),f.push({bodyAId:a.id,bodyBId:u.id,depth:o.depth,start:o.start}))}}}}if(!y)break}for(const s of i)s.restingTime+=1/t,Math.abs(s.center.x-s.averageCenter.x)>.1&&(s.averageCenter.x=s.center.x,s.restingTime=0),Math.abs(s.center.y-s.averageCenter.y)>.1&&(s.averageCenter.y=s.center.y,s.restingTime=0),Math.abs(s.angle-s.averageAngle)>=.05&&(s.averageAngle=s.angle,s.restingTime=0),s.velMag=E(s.velocity);return f}l.worldStep=ge;function ve(t,e,i=!1){const n=t.staticBodies;for(const r of n)if(te(e,r)){i&&i&&console.log("Collide",e.center.y,r.center.y,e.shapes[0],r.shapes[0]);let f=Y();if(se(t,e,r,f))return!0}return!1}l.collidingWithStatic=ve;function Ce(t,e=1,i){return!(i??t.dynamicBodies).find(n=>n.restingTime<e)}l.atRest=Ce;function m(t,e){return{x:t,y:e}}l.newVec2=m;function E(t){return R(t,t)**.5}l.lengthVec2=E;function Z(t,e){let i=Math.acos(R(V(d(t,-1)),V(e)));return R(m(-t.y,t.x),e)<0&&(i=-i),i}l.angleBetween=Z;function v(t,e){return m(t.x+e.x,t.y+e.y)}l.addVec2=v;function B(t,e){return v(t,d(e,-1))}l.subtractVec2=B;function d(t,e){return m(t.x*e,t.y*e)}l.scaleVec2=d;function R(t,e){return t.x*e.x+t.y*e.y}l.dotProduct=R;function b(t,e){return t.x*e.y-t.y*e.x}l.crossProduct=b;function G(t,e,i){const n=t.x-e.x,r=t.y-e.y;return m(n*Math.cos(i)-r*Math.sin(i)+e.x,n*Math.sin(i)+r*Math.cos(i)+e.y)}l.rotateVec2=G;function V(t){return d(t,1/(E(t)||1))}l.normalize=V;function Re(t,e){t.velocity.x+=e.x,t.velocity.y+=e.y,t.restingTime=0}l.applyVelocity=Re;const Y=()=>({depth:0,normal:m(0,0),start:m(0,0),end:m(0,0),shapeA:void 0,shapeB:void 0});function I(t,e,i,n,r,f){if(!(t.depth>=e)){if(r.sensor){r.sensorColliding=!0,r.sensorCollisions.push(f.id);return}if(f.sensor){f.sensorColliding=!0,f.sensorCollisions.push(r.id);return}t.depth=e,t.normal.x=i.x,t.normal.y=i.y,t.start.x=n.x,t.start.y=n.y,t.end=v(n,d(i,e)),t.shapeA=r,t.shapeB=f}}function $(t,e){return t.type===g.RECTANGLE?(Math.hypot(t.width,t.height)/2,e>0?1/(e*(t.width**2+t.height**2)/12):0):e>0?e*t.bounds**2/12:0}function w(t,e,i,n=!1){return e.x=Math.floor(e.x),e.y=Math.floor(e.y),i=Math.floor(i),{id:t.nextId++,type:g.CIRCLE,center:e,bounds:i,boundingBox:q(g.CIRCLE,i,[],e),sensor:n,sensorColliding:!1,sensorCollisions:[],inertia:0}}l.createCircleShape=w;function ee(t,e,i,n,r=0,f=!1){e.x=Math.floor(e.x),e.y=Math.floor(e.y),i=Math.floor(i),n=Math.floor(n);const s=[m(e.x-i/2,e.y-n/2),m(e.x+i/2,e.y-n/2),m(e.x+i/2,e.y+n/2),m(e.x-i/2,e.y+n/2)];if(r!==0)for(let a=0;a<4;a++)s[a]=G(s[a],e,r);const y=ne(s),c=Math.hypot(i,n)/2;return{id:t.nextId++,type:g.RECTANGLE,width:i,height:n,center:e,vertices:s,faceNormals:y,bounds:c,boundingBox:q(g.RECTANGLE,c,s,e),sensor:f,sensorColliding:!1,sensorCollisions:[],inertia:0,angle:r}}l.createRectangleShape=ee;function z(t,e,i,n,r,f,s,y=!1){const c={id:t.nextId++,center:e,friction:n,restitution:r,shapes:f,static:!0,angle:0,permeability:0,data:s??null,type:"BODY"};for(const a of f)a.inertia=$(a,i),a.bodyId=c.id;return i?{...c,static:!1,averageCenter:m(e.x,e.y),centerOfPhysics:{...e},mass:1/i,velMag:0,velocity:m(0,0),acceleration:y?{x:0,y:0}:t.gravity,averageAngle:0,angularVelocity:0,angularAcceleration:0,inertia:$(f[0],i),restingTime:0,fixedPosition:!1,fixedRotation:!1,floating:y}:c}l.createRigidBody=z;function Ee(t,e,i){e.static?t.staticBodies.push(e):(i??t.dynamicBodies).push(e)}l.addBody=Ee;function Ae(t,e,i){const n=e.static?t.staticBodies:i??t.dynamicBodies,r=n.findIndex(f=>f.id==e.id);r>=0&&n.splice(r,1)}l.removeBody=Ae;function te(t,e){for(const i of t.shapes)for(const n of e.shapes){const r=Math.abs(i.center.x-n.center.x)<i.boundingBox.x+n.boundingBox.x,f=Math.abs(i.center.y-n.center.y)<i.boundingBox.y+n.boundingBox.y;if(r&&f)return!0}return!1}function ie(t){t.boundingBox=q(t.type,t.bounds,t.type===g.RECTANGLE?t.vertices:[],t.center)}function q(t,e,i,n){if(t===g.CIRCLE)return{x:e,y:e};{let r=0,f=0;for(const s of i)r=Math.max(r,Math.abs(n.x-s.x)),f=Math.max(f,Math.abs(n.y-s.y));return{x:r,y:f}}}function Me(t){t.faceNormals=ne(t.vertices)}function ne(t){const e=[];for(let i=4;i--;)e[i]=V(B(t[(i+1)%4],t[(i+2)%4]));return e}function ae(t,e,i){let n,r,f,s,y=1e9,c=-1,a=!0,p,u;for(r=4;a&&r--;){n=t.faceNormals[r];const o=d(n,-1),x=t.vertices[r];let C,h;for(u=-1e9,p=-1,f=4;f--;)C=B(e.vertices[f],x),h=R(C,o),h>0&&h>u&&(p=e.vertices[f],u=h);a=p!==-1,a&&u<y&&(y=u,c=r,s=p)}return a&&I(i,y,t.faceNormals[c],v(s,d(t.faceNormals[c],y)),t,e),a}function S(t,e){return e.static?!0:e.restingTime>t.restTime}function se(t,e,i,n){if(S(t,e)&&S(t,i))return!1;let r=e,f=i;for(let s of e.shapes)for(let y of i.shapes){let c=s,a=y;if(e=r,i=f,c.type==g.CIRCLE&&a.type===g.CIRCLE){const p=B(a.center,c.center),u=c.bounds+a.bounds,o=E(p);if(o<=Math.sqrt(u*u)){const x=V(d(p,-1)),C=d(x,a.bounds);I(n,u-o,V(p),v(a.center,C),c,a);continue}continue}if(c.type==g.RECTANGLE&&a.type==g.RECTANGLE){let p=!1,u=!1;const o=Y();if(p=ae(c,a,o),p){const x=Y();if(u=ae(a,c,x),u)if(o.depth<x.depth){I(n,o.depth,o.normal,B(o.start,d(o.normal,o.depth)),o.shapeA,x.shapeB);continue}else{I(n,x.depth,d(x.normal,-1),x.start,x.shapeB,x.shapeA);continue}}continue}if(c.type===g.CIRCLE&&a.type===g.RECTANGLE&&([c,a]=[a,c]),c.type===g.RECTANGLE&&a.type===g.CIRCLE){let p=1,u=-1e9,o=0,x,C,h,T;for(x=4;x--;){if(h=a.center,C=B(h,c.vertices[x]),T=R(C,c.faceNormals[x]),T>0){u=T,o=x,p=0;break}T>u&&(u=T,o=x)}let P,A;if(p&&h){I(n,a.bounds-u,c.faceNormals[o],B(h,d(c.faceNormals[o],a.bounds)),c,a);continue}else if(h){let M=B(h,c.vertices[o]),N=B(c.vertices[(o+1)%4],c.vertices[o]),D=R(M,N);if(D<0){if(P=E(M),P>a.bounds)continue;A=V(M),I(n,a.bounds-P,A,v(h,d(A,-a.bounds)),c,a);continue}else if(M=B(h,c.vertices[(o+1)%4]),N=d(N,-1),D=R(M,N),D<0){if(P=E(M),P>a.bounds)continue;A=V(M),I(n,a.bounds-P,A,v(h,d(A,-a.bounds)),c,a);continue}else if(u<a.bounds){I(n,a.bounds-u,c.faceNormals[o],B(h,d(c.faceNormals[o],a.bounds)),c,a);continue}else continue}continue}}return n.depth>0}function Ve(t,e,i,n){if(S(t,e)&&S(t,i))return!1;const r=e.static?0:e.mass,f=i.static?0:i.mass,s=e.static?0:e.inertia,y=i.static?0:i.inertia,c=n.depth/(r+f)*.8,a=d(n.normal,c),p=n.normal;if(a.x===0&&a.y===0)return!1;e.static||L(e,d(a,-r)),i.static||L(i,d(a,f));const u=d(n.start,f/(r+f)),o=d(n.end,r/(r+f)),x=v(u,o),C=B(x,e.static?e.center:e.centerOfPhysics),h=B(x,i.static?i.center:i.centerOfPhysics),T=e.static?m(0,0):v(e.velocity,m(-1*e.angularVelocity*C.y,e.angularVelocity*C.x)),P=i.static?m(0,0):v(i.velocity,m(-1*i.angularVelocity*h.y,i.angularVelocity*h.x)),A=B(P,T),M=R(A,p);if(M>0)return!1;const N=Math.min(e.restitution,i.restitution),D=Math.min(e.friction,i.friction),X=b(C,p),_=b(h,p),j=-(1+N)*M/(r+f+X*X*s+_*_*y);let J=d(p,j);e.static||(e.fixedPosition||(e.velocity=B(e.velocity,d(J,e.mass))),e.fixedRotation||(e.angularVelocity-=X*j*e.inertia)),i.static||(i.fixedPosition||(i.velocity=v(i.velocity,d(J,i.mass))),i.fixedRotation||(i.angularVelocity+=_*j*i.inertia));const k=d(V(B(A,d(p,R(A,p)))),-1),H=b(C,k),K=b(h,k);let W=-(1+N)*R(A,k)*D/(r+f+H*H*s+K*K*y);return W>j&&(W=j),J=d(k,W),e.static||(e.velocity=B(e.velocity,d(J,e.mass)),e.angularVelocity-=H*W*e.inertia,e.velocity.x*=t.damp,e.velocity.y*=t.damp,e.angularVelocity*=t.angularDamp),i.static||(i.velocity=v(i.velocity,d(J,i.mass)),i.angularVelocity+=K*W*i.inertia,i.velocity.x*=t.damp,i.velocity.y*=t.damp,i.angularVelocity*=t.angularDamp),!0}})(physics||(physics={}));
