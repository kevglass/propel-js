"use strict";export var physics;(function(p){let g;(function(t){t[t.CIRCLE=0]="CIRCLE",t[t.RECTANGLE=1]="RECTANGLE"})(g=p.ShapeType||(p.ShapeType={}));function O(t,e){return[...e??t.dynamicBodies,...t.staticBodies,...t.disabledBodies]}p.allBodies=O;function Q(t,e){return[...e??t.dynamicBodies,...t.staticBodies]}p.enabledBodies=Q;function se(t,e,i){const n=(i??t.dynamicBodies).findIndex(f=>f.id===e.id);n!==-1&&(i??t.dynamicBodies).splice(n,1);const r=t.staticBodies.findIndex(f=>f.id===e.id);r!==-1&&t.staticBodies.splice(r,1),t.disabledBodies.includes(e)||t.disabledBodies.push(e)}p.disableBody=se;function oe(t,e,i){!e.static&&!(i??t.dynamicBodies).find(n=>n.id===e.id)&&(i??t.dynamicBodies).push(e),e.static&&!t.staticBodies.includes(e)&&t.staticBodies.push(e),t.disabledBodies.includes(e)&&t.disabledBodies.splice(t.disabledBodies.indexOf(e),1)}p.enableBody=oe;function ce(t,e=!1,i){const n=e?t.staticBodies:O(t,i);if(n.length===0)return{min:B(0,0),max:B(0,0)};const r=n[0];let f=B(r.shapes[0].center.x-r.shapes[0].bounds,r.center.y-r.shapes[0].bounds),s=B(r.shapes[0].center.x+r.shapes[0].bounds,r.center.y+r.shapes[0].bounds);for(const y of n)for(const c of y.shapes)if(c.type===g.CIRCLE)f.x=Math.min(f.x,c.center.x-c.bounds),f.y=Math.min(f.y,c.center.y-c.bounds),s.x=Math.max(s.x,c.center.x+c.bounds),s.y=Math.max(s.y,c.center.y+c.bounds);else if(c.type===g.RECTANGLE)for(const a of c.vertices)f.x=Math.min(f.x,a.x),f.y=Math.min(f.y,a.y),s.x=Math.max(s.x,a.x),s.y=Math.max(s.y,a.y);return{min:f,max:s}}p.getWorldBounds=ce;function re(t,e=1){return{staticBodies:[],dynamicBodies:[],disabledBodies:[],gravity:t??B(0,100),angularDamp:1,damp:1,nextId:1,joints:[],frameCount:0,jointRestriction:1,restTime:e,exclusions:{},paused:!1}}p.createWorld=re;function fe(t,e,i){t.exclusions[e.id]=t.exclusions[e.id]??[],t.exclusions[e.id].includes(i.id)||t.exclusions[e.id].push(i.id),t.exclusions[i.id]=t.exclusions[i.id]??[],t.exclusions[i.id].includes(e.id)||t.exclusions[i.id].push(e.id)}p.excludeCollisions=fe;function le(t,e,i){t.exclusions[e.id]&&(t.exclusions[e.id]=t.exclusions[e.id].filter(n=>i.id===n)),t.exclusions[i.id]&&(t.exclusions[i.id]=t.exclusions[e.id].filter(n=>e.id===n))}p.includeCollisions=le;function ue(t,e,i,n=1,r=0,f=!1){const s={bodyA:e.type==="BODY"?e.id:e.bodyId,bodyB:i.type==="BODY"?i.id:i.bodyId,distance:0,rigidity:n,elasticity:r,soft:f,shapeA:e.type!=="BODY"?e.id:0,shapeB:i.type!=="BODY"?i.id:0},y=O(t).find(l=>l.id===s.bodyA),c=O(t).find(l=>l.id===s.bodyB);if(!y||!c)throw"Body A is not part of world. Joints must be connected to elements in the world";const a=s.shapeA?y.shapes.find(l=>l.id===s.shapeA).center:y.center,d=s.shapeB?c.shapes.find(l=>l.id===s.shapeB).center:c.center;s.distance=R(m(a,d)),t.joints.push(s)}p.createJoint=ue;function de(t,e,i,n,r,f,s=!1,y){const c=$(t,e,i,s);return z(t,e,n,r,f,[c],y)}p.createCircle=de;function pe(t,e,i,n,r,f,s,y=!1,c){const a=w(t,e,i,n,0,y);return z(t,e,r,f,s,[a],c)}p.createRectangle=pe;function U(t,e){L(t,e,!0)}p.moveBody=U;function L(t,e,i=!1){if(!(!i&&t.static)){t.center=v(t.center,e),t.static||(t.centerOfPhysics=v(t.centerOfPhysics,e));for(const n of t.shapes)if(n.center=v(n.center,e),n.type===g.RECTANGLE){for(let r=4;r--;)n.vertices[r]=v(n.vertices[r],e);te(n)}}}function ye(t,e){const i=m(e,t.center);U(t,i)}p.setCenter=ye;function xe(t,e){const i=e-t.angle;t.static||(t.centerOfPhysics={...t.center}),F(t,i)}p.setRotation=xe;function F(t,e){if(!e)return;t.angle+=e,t.static||(t.averageAngle=t.angle);const i=t.static?t.center:t.centerOfPhysics;t.center=G(t.center,i,e);for(const n of t.shapes)if(n.center=G(n.center,i,e),n.type===g.RECTANGLE){for(let r=4;r--;)n.vertices[r]=G(n.vertices[r],i,e);Ae(n),te(n)}}p.rotateBody=F;function he(t,e,i,n,r){const f=e.bodyA===i.id?e.shapeA:e.shapeB,s=e.bodyA===i.id?e.shapeB:e.shapeA,y=f?i.shapes.find(o=>o.id===f).center:i.center,c=s?n.shapes.find(o=>o.id===s).center:n.center;let a=m(c,y);if(R(a)-e.distance!=0){if(!i.static){const C=m(i.centerOfPhysics,y);if(R(C)>0){let h=Math.atan2(-a.y,-a.x)-Math.atan2(C.y,C.x);h>Math.PI&&(h=Math.PI-h),h<-Math.PI&&(h=Math.PI*2+h),i.angularVelocity+=h/r}}a=m(c,y);const o=R(a),x=o-e.distance;x!=0&&(x>0?a=u(a,1/o*x*(1-e.elasticity)*(n.static?1:.5)):a=u(a,1/o*x*e.rigidity*(n.static?1:.5)),!e.soft&&!i.static&&L(i,a),!e.soft&&!n.static&&L(n,u(a,-1)),i.static||(i.velocity=v(i.velocity,u(a,e.soft?1:r/2))),n.static||(n.velocity=v(n.velocity,u(a,-(e.soft?1:r/2)))))}}function me(t,e,i){if(e.paused)return[];i=i??e.dynamicBodies;const n=Q(e,i),r=O(e,i);let f=[];for(const s of r)s.shapes.forEach(y=>{!s.static&&s.restingTime>e.restTime||(y.sensorColliding=!1,y.sensorCollisions=[])});for(const s of i)!s.velocity&&!s.acceleration||(s.velMag!==R(s.velocity)&&(s.restingTime=0),!S(e,s)&&(s.fixedPosition?(s.velocity.x=0,s.velocity.y=0):(s.velocity=v(s.velocity,u(s.acceleration,1/t)),L(s,u(s.velocity,1/t))),s.fixedRotation?(s.angularVelocity=0,s.angularAcceleration=0):(s.angularVelocity+=s.angularAcceleration*1/t,F(s,s.angularVelocity*1/t))));for(let s=9;s--;){let y=!1;for(const c of i){const a=e.joints.filter(d=>d.bodyA===c.id||d.bodyB===c.id);for(const d of a){const l=d.bodyA===c.id?d.bodyB:d.bodyA,o=r.find(x=>x.id===l);o&&(he(e,d,c,o,t),(c.static||o.static)&&(c.static||(c.velocity.x-=c.velocity.x*(1-e.damp)/t*e.jointRestriction,c.velocity.y-=c.velocity.y*(1-e.damp)/t*e.jointRestriction,c.angularVelocity-=c.angularVelocity*(1-e.angularDamp)/t*e.jointRestriction),o.static||(o.velocity.x-=o.velocity.x*(1-e.damp)/t*e.jointRestriction,o.velocity.y-=o.velocity.y*(1-e.damp)/t*e.jointRestriction,o.angularVelocity-=o.angularVelocity*(1-e.angularDamp)/t*e.jointRestriction)))}}for(let c=i.length;c--;){const a=i[c];if(a.velocity)for(let d=n.length;d-- >c;){if(c===d)continue;const l=n[d];if(!e.exclusions[l.id]?.includes(a.id)&&!e.exclusions[a.id]?.includes(l.id)&&ee(a,l)){let o=j();if(ae(e,a,l,o)){if(o.shapeA&&o.shapeA.sensor){o.shapeA.sensorColliding=!0,o.shapeB&&o.shapeA.sensorCollisions.push(o.shapeB.id);continue}if(o.shapeB&&o.shapeB.sensor){o.shapeB.sensorColliding=!0,o.shapeA&&o.shapeB.sensorCollisions.push(o.shapeA.id);continue}if(l.permeability>0){a.velocity.x*=1-l.permeability,a.velocity.y*=1-l.permeability,a.angularVelocity*=1-l.permeability;continue}a.static||(a.shapes.includes(o.shapeA)&&!o.shapeA.sensor&&(a.centerOfPhysics={...o.shapeA.center},a.inertia=o.shapeA.inertia),a.shapes.includes(o.shapeB)&&!o.shapeB.sensor&&(a.centerOfPhysics={...o.shapeB.center},a.inertia=o.shapeB.inertia)),l.static||(l.shapes.includes(o.shapeA)&&!o.shapeA.sensor&&(l.centerOfPhysics={...o.shapeA.center},l.inertia=o.shapeA.inertia),l.shapes.includes(o.shapeB)&&!o.shapeB.sensor&&(l.centerOfPhysics={...o.shapeB.center},l.inertia=o.shapeB.inertia)),E(o.normal,m(l.center,a.center))<0&&(o={depth:o.depth,normal:u(o.normal,-1),start:o.end,end:o.start,shapeA:o.shapeB,shapeB:o.shapeA}),Ee(e,a,l,o)&&(y=!0,f=f.filter(x=>x.bodyAId!==a.id&&x.bodyBId!==l.id),f.push({bodyAId:a.id,bodyBId:l.id,depth:o.depth,start:o.start}))}}}}if(!y)break}for(const s of i)s.restingTime+=1/t,Math.abs(s.center.x-s.averageCenter.x)>.1&&(s.averageCenter.x=s.center.x,s.restingTime=0),Math.abs(s.center.y-s.averageCenter.y)>.1&&(s.averageCenter.y=s.center.y,s.restingTime=0),Math.abs(s.angle-s.averageAngle)>=.05&&(s.averageAngle=s.angle,s.restingTime=0),s.velMag=R(s.velocity);return f}p.worldStep=me;function Be(t,e,i=!1){const n=t.staticBodies;for(const r of n)if(ee(e,r)){i&&i&&console.log("Collide",e.center.y,r.center.y,e.shapes[0],r.shapes[0]);let f=j();if(ae(t,e,r,f))return!0}return!1}p.collidingWithStatic=Be;function ge(t,e=1,i){return!(i??t.dynamicBodies).find(n=>n.restingTime<e)}p.atRest=ge;function B(t,e){return{x:t,y:e}}p.newVec2=B;function R(t){return E(t,t)**.5}p.lengthVec2=R;function v(t,e){return B(t.x+e.x,t.y+e.y)}p.addVec2=v;function m(t,e){return v(t,u(e,-1))}p.subtractVec2=m;function u(t,e){return B(t.x*e,t.y*e)}p.scaleVec2=u;function E(t,e){return t.x*e.x+t.y*e.y}p.dotProduct=E;function b(t,e){return t.x*e.y-t.y*e.x}p.crossProduct=b;function G(t,e,i){const n=t.x-e.x,r=t.y-e.y;return B(n*Math.cos(i)-r*Math.sin(i)+e.x,n*Math.sin(i)+r*Math.cos(i)+e.y)}p.rotateVec2=G;function P(t){return u(t,1/(R(t)||1))}p.normalize=P;function ve(t,e){console.log("ApplyL "+e.x+" "+e.y),t.velocity.x+=e.x,t.velocity.y+=e.y,t.restingTime=0}p.applyVelocity=ve;const j=()=>({depth:0,normal:B(0,0),start:B(0,0),end:B(0,0),shapeA:void 0,shapeB:void 0});function V(t,e,i,n,r,f){if(!(t.depth>=e)){if(r.sensor){r.sensorColliding=!0,r.sensorCollisions.push(f.id);return}if(f.sensor){f.sensorColliding=!0,f.sensorCollisions.push(r.id);return}t.depth=e,t.normal.x=i.x,t.normal.y=i.y,t.start.x=n.x,t.start.y=n.y,t.end=v(n,u(i,e)),t.shapeA=r,t.shapeB=f}}function Z(t,e){return t.type===g.RECTANGLE?(Math.hypot(t.width,t.height)/2,e>0?1/(e*(t.width**2+t.height**2)/12):0):e>0?e*t.bounds**2/12:0}function $(t,e,i,n=!1){return e.x=Math.floor(e.x),e.y=Math.floor(e.y),i=Math.floor(i),{id:t.nextId++,type:g.CIRCLE,center:e,bounds:i,boundingBox:q(g.CIRCLE,i,[],e),sensor:n,sensorColliding:!1,sensorCollisions:[],inertia:0}}p.createCircleShape=$;function w(t,e,i,n,r=0,f=!1){e.x=Math.floor(e.x),e.y=Math.floor(e.y),i=Math.floor(i),n=Math.floor(n);const s=[B(e.x-i/2,e.y-n/2),B(e.x+i/2,e.y-n/2),B(e.x+i/2,e.y+n/2),B(e.x-i/2,e.y+n/2)];if(r!==0)for(let a=0;a<4;a++)s[a]=G(s[a],e,r);const y=ie(s),c=Math.hypot(i,n)/2;return{id:t.nextId++,type:g.RECTANGLE,width:i,height:n,center:e,vertices:s,faceNormals:y,bounds:c,boundingBox:q(g.RECTANGLE,c,s,e),sensor:f,sensorColliding:!1,sensorCollisions:[],inertia:0,angle:r}}p.createRectangleShape=w;function z(t,e,i,n,r,f,s,y=!1){const c={id:t.nextId++,center:e,friction:n,restitution:r,shapes:f,static:!0,angle:0,permeability:0,data:s??null,type:"BODY"};for(const a of f)a.inertia=Z(a,i),a.bodyId=c.id;return i?{...c,static:!1,averageCenter:B(e.x,e.y),centerOfPhysics:{...e},mass:1/i,velMag:0,velocity:B(0,0),acceleration:y?{x:0,y:0}:t.gravity,averageAngle:0,angularVelocity:0,angularAcceleration:0,inertia:Z(f[0],i),restingTime:0,fixedPosition:!1,fixedRotation:!1,floating:y}:c}p.createRigidBody=z;function Ce(t,e,i){e.static?t.staticBodies.push(e):(i??t.dynamicBodies).push(e)}p.addBody=Ce;function Re(t,e,i){const n=e.static?t.staticBodies:i??t.dynamicBodies,r=n.findIndex(f=>f.id==e.id);r>=0&&n.splice(r,1)}p.removeBody=Re;function ee(t,e){for(const i of t.shapes)for(const n of e.shapes){const r=Math.abs(i.center.x-n.center.x)<i.boundingBox.x+n.boundingBox.x,f=Math.abs(i.center.y-n.center.y)<i.boundingBox.y+n.boundingBox.y;if(r&&f)return!0}return!1}function te(t){t.boundingBox=q(t.type,t.bounds,t.type===g.RECTANGLE?t.vertices:[],t.center)}function q(t,e,i,n){if(t===g.CIRCLE)return{x:e,y:e};{let r=0,f=0;for(const s of i)r=Math.max(r,Math.abs(n.x-s.x)),f=Math.max(f,Math.abs(n.y-s.y));return{x:r,y:f}}}function Ae(t){t.faceNormals=ie(t.vertices)}function ie(t){const e=[];for(let i=4;i--;)e[i]=P(m(t[(i+1)%4],t[(i+2)%4]));return e}function ne(t,e,i){let n,r,f,s,y=1e9,c=-1,a=!0,d,l;for(r=4;a&&r--;){n=t.faceNormals[r];const o=u(n,-1),x=t.vertices[r];let C,h;for(l=-1e9,d=-1,f=4;f--;)C=m(e.vertices[f],x),h=E(C,o),h>0&&h>l&&(d=e.vertices[f],l=h);a=d!==-1,a&&l<y&&(y=l,c=r,s=d)}return a&&V(i,y,t.faceNormals[c],v(s,u(t.faceNormals[c],y)),t,e),a}function S(t,e){return e.static?!0:e.restingTime>t.restTime}function ae(t,e,i,n){if(S(t,e)&&S(t,i))return!1;let r=e,f=i;for(let s of e.shapes)for(let y of i.shapes){let c=s,a=y;if(e=r,i=f,c.type==g.CIRCLE&&a.type===g.CIRCLE){const d=m(a.center,c.center),l=c.bounds+a.bounds,o=R(d);if(o<=Math.sqrt(l*l)){const x=P(u(d,-1)),C=u(x,a.bounds);V(n,l-o,P(d),v(a.center,C),c,a);continue}continue}if(c.type==g.RECTANGLE&&a.type==g.RECTANGLE){let d=!1,l=!1;const o=j();if(d=ne(c,a,o),d){const x=j();if(l=ne(a,c,x),l)if(o.depth<x.depth){V(n,o.depth,o.normal,m(o.start,u(o.normal,o.depth)),o.shapeA,x.shapeB);continue}else{V(n,x.depth,u(x.normal,-1),x.start,x.shapeB,x.shapeA);continue}}continue}if(c.type===g.CIRCLE&&a.type===g.RECTANGLE&&([c,a]=[a,c]),c.type===g.RECTANGLE&&a.type===g.CIRCLE){let d=1,l=-1e9,o=0,x,C,h,T;for(x=4;x--;){if(h=a.center,C=m(h,c.vertices[x]),T=E(C,c.faceNormals[x]),T>0){l=T,o=x,d=0;break}T>l&&(l=T,o=x)}let I,A;if(d&&h){V(n,a.bounds-l,c.faceNormals[o],m(h,u(c.faceNormals[o],a.bounds)),c,a);continue}else if(h){let M=m(h,c.vertices[o]),N=m(c.vertices[(o+1)%4],c.vertices[o]),D=E(M,N);if(D<0){if(I=R(M),I>a.bounds)continue;A=P(M),V(n,a.bounds-I,A,v(h,u(A,-a.bounds)),c,a);continue}else if(M=m(h,c.vertices[(o+1)%4]),N=u(N,-1),D=E(M,N),D<0){if(I=R(M),I>a.bounds)continue;A=P(M),V(n,a.bounds-I,A,v(h,u(A,-a.bounds)),c,a);continue}else if(l<a.bounds){V(n,a.bounds-l,c.faceNormals[o],m(h,u(c.faceNormals[o],a.bounds)),c,a);continue}else continue}continue}}return n.depth>0}function Ee(t,e,i,n){if(S(t,e)&&S(t,i))return!1;const r=e.static?0:e.mass,f=i.static?0:i.mass,s=e.static?0:e.inertia,y=i.static?0:i.inertia,c=n.depth/(r+f)*.8,a=u(n.normal,c),d=n.normal;if(a.x===0&&a.y===0)return!1;e.static||L(e,u(a,-r)),i.static||L(i,u(a,f));const l=u(n.start,f/(r+f)),o=u(n.end,r/(r+f)),x=v(l,o),C=m(x,e.static?e.center:e.centerOfPhysics),h=m(x,i.static?i.center:i.centerOfPhysics),T=e.static?B(0,0):v(e.velocity,B(-1*e.angularVelocity*C.y,e.angularVelocity*C.x)),I=i.static?B(0,0):v(i.velocity,B(-1*i.angularVelocity*h.y,i.angularVelocity*h.x)),A=m(I,T),M=E(A,d);if(M>0)return!1;const N=Math.min(e.restitution,i.restitution),D=Math.min(e.friction,i.friction),X=b(C,d),_=b(h,d),J=-(1+N)*M/(r+f+X*X*s+_*_*y);let W=u(d,J);e.static||(e.fixedPosition||(e.velocity=m(e.velocity,u(W,e.mass))),e.fixedRotation||(e.angularVelocity-=X*J*e.inertia)),i.static||(i.fixedPosition||(i.velocity=v(i.velocity,u(W,i.mass))),i.fixedRotation||(i.angularVelocity+=_*J*i.inertia));const k=u(P(m(A,u(d,E(A,d)))),-1),H=b(C,k),K=b(h,k);let Y=-(1+N)*E(A,k)*D/(r+f+H*H*s+K*K*y);return Y>J&&(Y=J),W=u(k,Y),e.static||(e.velocity=m(e.velocity,u(W,e.mass)),e.angularVelocity-=H*Y*e.inertia,e.velocity.x*=t.damp,e.velocity.y*=t.damp,e.angularVelocity*=t.angularDamp),i.static||(i.velocity=v(i.velocity,u(W,i.mass)),i.angularVelocity+=K*Y*i.inertia,i.velocity.x*=t.damp,i.velocity.y*=t.damp,i.angularVelocity*=t.angularDamp),!0}})(physics||(physics={}));
